Domain model

	I cannot stress it enough. This is the most important part of any project or application and ActiveQuant is no exception. While the idea of AQ's domain model follows a {{{http://en.wikipedia.org/wiki/Domain-driven_design}domain driven design}} methodology, it is in its current implementation not implementing DDD in its entirety. 

	The domain model is split into an instrument section and a trading and simulation section. The latter makes only sense with the former. 

Implementation details

	The implementation evolves around a so called persistent entities (see {{{./apidocs/com/activequant/domainmodel/PersistentEntity.html}JavaDocs}}). All domain model entities should contain only Double, String and Long values and arrays thereof. The persistent entity is a smart object that can convert an object and its properties to and from a map object. The code itself is pretty lean and uses reflection a lot. In the near future, this might change, but has served very well so far. 


In general ...

      ... we distinguish between an instrument, data feed instrument and traded instrument. 
      One instrument can be available from multiple data feeds and multiple trading venues. 
      Data feed and trading venue are two separate entities. Trading venues are not the same as 
      data feed locations, for example Bloomberg and EUREX. Nonetheless, a trading venue could 
      also provide a market data feed, in which case we would have a data feed entry for EUREX next to 
      EUREX as a trading venue for an instrument.    

      In order to fetch information from the archive, you have to specify which _specific_ market data instrument you would 
      like to load. 


Domain model overview

	The following diagram shows how these entities relate to each other. 

[./images/domainmodel.png] Domain model
		

* Instrument information domain model 

	TBW

* Trading and simulation domain model
	
	TBW

