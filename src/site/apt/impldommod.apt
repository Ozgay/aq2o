How to persist new classes with ActiveQuant

	There are cases when the existing domain model classes in ActiveQuant are not satisfying and sufficient for your specific needs. Luckily AQ provides standard access mechanisms to databases and a storage layer, which you can leverage easily to store your own classes. All you have to do to make this mechanism work, is to follow some clear implementation rules, development rules that have emerged over the period of development and have proven several times their validity. But before we dive into how to implement your own mechanisms, let us have a look at the general approach AQ takes. 

	First of all, let's talk a bit about the general framework and how storage mechanisms are implemented in it. As you already know, AQ uses Spring and thus allows modification and rewiring of entire applications, which also includes the database and storage layer. The existing storage layer has a configuration file where you can specify low level parameters, such as database driver, URL, username and password. The existing storage layer implements the AQ DAO interface for a large variety of typical domain model objects. In general you can also implement the DAO interfaces as non-database backed classes, a good example of such an implementation is the JUnit test storage layer, an in-memory implementation, also called mock implementation. The entire storage layer, at least the delivered one, as said, follows the DAO approach. Let us recap what a DAO approach looks like. 

	Now let us talk about the domain model objects and how these domain model objects look like, meaning which functions they have to implement to the framework in order to work with the current approach. If you have not yet had a look at the inner workings of AQ and in particular at the domain model classes, such as Future, Stock, Country or Venue, it is now a good time to do so before we dive into the details. 

	Now that you have had a look, we can continue our exploration of the existing system. As you hopefully noticed, the existing domain model is derived from a class called PersistentEntity. PersistentEntity and its extensions require the developer to implement a couple of methods so that it all fits together nicely. What we have not mentioned, is that the P.E. is not only relevant for the DAO layer and storing things, but that it is also relevant for the external and internal messaging system when it comes to sending information over the wire to other end points within your AQ infrastructure. The getID() method is used to obtain a unique ID from the object, which is used to identify the object in the database. This ID is the sole identifier of the object in the entire system. In addition to this, so called snapshot objects have a non-unique ID, as the unique ID of snapshots is compound from the non-unique ID and the timestamp of a snapshot. Hopefully you also noticed that most of the getters (the getXYZ methods) are marked with a Java annotation @Property. The MyBatis layer of AQ uses these annotations to know which methods and which properties the information in a database belongs to. The entire storage mechanism of AQ is quite complex, but the approach taken allows transparent storage for any type of object that adheres to the design guidelines. Ensure that your getters and setters are always called like the property and that they are named cohesively, meaning you should have a getDate and a setDate, but not a getDate and a setTimeStamp if these two methods correspond to the same property. But of course you may also add additional utility methods, which do not reflect what is stored in the database, but which provide additional functionality to the user. As an additional hint, use only Long, String and Double in your domain model objects. Now, let's proceed to the DAO implementation. 

	First of all, let's clarify what DAO stands for. DAO stands for Data Access Object and describes a design approach how to design and later also implement a flexible storage mechanism that allows easy reimplementation of designed storage interfaces for new environments and requirements. A DAO layer is compound of interfaces and implementations of these interfaces. The interfaces define what sort of functionality the layer provides. From a software architectural point of view, upper layers know only about and use only the DAO interface methods. The defined methods in a DAO interface go beyond CRUD methods (Create, Read, Update and Delete) and typically include domain specific functions. Typical examples of domain specific methods are domain specific search functions, let's make a more concrete example: a function that requires two timestamps and returns all futures that are traded between these timestamps. It is up to you to define your use-case specific interfaces. When designing your own DAO interfaces for your own domain model objects, extend in your DAO interface AQ's IEntityDao. Have a look at the existing DAO interface definitions, such as IInstrumentDao, for inspiration. When you are satisfied with the design of your interface, proceed to implementation. 

	Let us now have a look at how ActiveQuant stores things in the database. If you would like to see what we are talking about, open up a prompt to your database, in case of MySQL open up a MySQL command line and execute some commands while you read along.

	Let's hope you already stored some objects in your database, so that you can see what we are describing here. The table names that you see are defined in the DAO implementation. When looking at the table structures, you will notice that all table structures look the same, regardless whether they store venues, countries, instruments or market data instruments. The reason for this is the storage approach of ActiveQuant, which uses by default the DAO implementation. We will talk about this storage approach more in a second. 

	Now let's talk more about the existing storage approach. ActiveQuant uses a map based storage approach, that means, it always stores objects and the properties of these objects in the same way. It stores the property name into the fieldname column and the property value into one of three columns, either into longVal, stringVal or doubleVal, depending on the property type. There are some implications and weaknesses of this approach, but reality shows that it proves to be a very efficient and form the development time point of view, a very fast approach to store information into the database. It can also store arrays, but arrays are for now a bit too complicated to explain. You will have noticed as well, that you can see the same keyVal entry in the table in several rows. That's because the table key is not just the keyVal, but actually a compound key made up of the ID as it is returned from the Java object and the fieldname as it is introspected during object-to-row conversion. Although we said it already, I want to stress again, ActiveQuant can by default only store doubles, strings and longs - it cannot persist in its current state more complex object structures out of the box. This highlights also the weakness of this storage approach. As you saw, one object is stored into multiple rows in the database. And of course the performance impact of this approach is high. With flexibility comes a lack of performance. Let me give you something on your way. In most applications I saw, storing things to database was not done  to store information immediately afterwards, usually database storage and retrieval were a time-wise rather decoupled and disconnected process. What do we mean by this? We mean, that we do not store information in the database and five seconds later retrieve the information. Usually information is stored and hours later, in a separate process it is loaded and used. It is also usual that information is loaded once in an application and then used several times without reloading the information from the database. As an example, when information has been stored, the system, such as a production trading system, loads the information once on startup and keeps it in memory for later use. So in none of these cases is database performance crucial or of highest priority. Again, keep in mind that you can always implement your own storage layer and exchange the shipped approach with your own as long as you implement the AQ DAO interfaces. I hope this short introduction into AQ's storage was ok for you. 

	Now, move on your own. 

